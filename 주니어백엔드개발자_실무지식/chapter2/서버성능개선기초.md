# 서버 성능 개선 기초

**수직 확장과 수평 확장**
 - 수직 확장(Scale up): CPU, memory, disk 등 리소스를 증가시키는 것, 즉각적인 효과가 나타나지만 언제까지 늘릴수만은 없음
 - 수평 확장(Scale out): 서버를 늘리는 방법
   - 먼저 병목 지점을 파악하고 서버를 추가해야 함
     - 만약 DB에서 성능 문제가 발생하는데 DB를 사용하는 서버를 늘리면, DB에 가해지는 부하만 더 커지고 성능 문제가 심해짐(외부 API 호출도 마찬가지) 
 - 로드 밸런서: 사용자의 트래픽을 각 서버에 골고루 분배해 한 서버에 트래픽이 몰리는 것을 방지함, 전체 서버 자원을 효율적으로 사용 가능
   - 알고리즘
     - 정적 방식: 라운드로빈(클라이언트의 요청을 각 서버에 순차적으로 분배), IP 해시(클라이언트의 IP주소를 해시한 값을 기반으로 요청을 전달할 서버를 결정, 항상 동일한 서버로 지정)
     - 동적 방식: 서버의 현재 상태에 따라 트래픽을 분산, 트래픽이 더 적거나 응답 시간이 더 짧은 서버에 요청을 보냄
    
**DB connection pool**
- 네트워크에서 DB를 연결하고 종료하는 시간은 전체 응답시간에 영향을 주는 문제를 해결하기 위해 DB 커넥션 풀을 사용
- 커넥션 풀: DB에 연결된 커넥션을 미리 생성해서 보관
  - 애플리케이션은 커넥션을 풀에서 가져오고, 작업완료시 다시 풀에 반환
  - 이미 연결된 커넥션을 재사용하므로 응답시간이 줄어들음
  - 설정 정보
    - 커넥션 풀 크기(또는 최소, 최대 크기): 미리 생성해둘 커넥션 개수 지정(가장 중요함!)
      - 트래픽이 순간적으로 급증할때, 커넥션 풀의 최소 크기를 최대 크기에 맞추는 것이 좋음(DB 연결 시간이 성능 저하의 주원인이 될 수도)
      - 그렇다고 무턱대고 늘리기만 하면 안됨, DB 서버의 CPU 사용률이 80%를 넘나드는 상황이면 DB에 가해지는 부하가 더 심해짐(크기를 유지하거나 더 줄이자)
    - 풀에 커넥션이 없을 때 커넥션을 구할 때까지 대기할 시간: 풀에 사용할 수 있는 커넥션이 없을 때 커넥션을 얻기 위해 기다릴 수 있는 최대 시간
      - HikariCP의 default 대기 시간: 30초
      - 지정된 대기 시간안에 커넥션을 구하지 못하면 DB 연결 실패 에러 발생
      - 대기시간 만큼 응답시간도 길어짐, 보통 0.5초에서 3초 이내로 지정하는 것이 좋음
      - 커넥션을 다 사용중일때, 무응답 상태로 유지되는 것보다 빠르게 에러를 반환하는 것이 나음 -> 서버의 부하 증가를 방지하게
    - 커넥션의 유지 시간(최대 유휴 시간, 최대 유지시간): 커넥션이 사용되지 않는 시간이 길어지면 연결이 끊어질 수 있음, 이때 DB와 연결이 끊긴 커넥션을 사용하면 에러가 발생함
      - 이러한 에러 방지를 위해 커넥션 풀은 2가지 기능 제공
        - 최대 유후 시간 지정: 사용되지 않는 커넥션을 풀에 유지할 수 있는 최대 시간
          - 이 시간을 DB에 설정된 비활성화 유지 시간보다 짧게 설정하면, DB가 연결을 끊기 전에 풀에서 커넥션 제거 가능
        - 유효성 검사 지원: 커넥션이 정상적으로 사용할 수 있는 상태인지 여부를 확인하는 절차
          - 이 과정을 통해 연결이 유효하지 않은 커넥션을 식별하고 풀에서 제거 가능
          - 유효성 검사를 위해 `SELECT 1 FROM dual` 쿼리를 실행하기도 함
        - 최대 유지 시간: 만약 이 값이 4시간이면 커넥션은 생성된 시점부터 최대 4시간까지만 유지, 4시간이 지나면 커넥션이 유효하더라도 커넥션을 닫고 풀에서 제거됨

**서버 캐시**
- Cache(Key: Value로 저장됨)에 자주 조회되는 데이터를 보관하여 응답 시간을 줄임
  - 데이터가 캐시에 없다면(Cache miss), DB에서 가져와 캐시에 저장
  - 데이터가 캐시에 있다면(Cache hit), 캐시에서 가져옴
- 적절한 Key 선택(중복 주의)
  - Ex) 게시글 상세 정보는 "articles:번호" 형태의 키 사용, 최신 인기 글은 "articles:hot10"을 키로 사용하는 식

**적중률과 삭제 규칙**
- 적중률(hit rate): 캐시가 얼마나 효율적으로 사용되는지 판단
  `hit rate = <캐시에 존재하는 건수>/<캐시에서 조회를 시도한 건수>`

  적중률이 높을 수록 DB와의 연동이 줄어들고 곧 응답 시간 감소, 처리량 증가, DB 부하 감소로 이어짐
  - 적중률을 높이는 방법: 캐시에 최대한 많은 데이터를 저장 BUT, 메모리 용량의 한계가 있기 때문에 무한대로 저장할 수는 없음
- 삭제 규칙: 캐시가 가득차있을 때, 기존의 데이터를 삭제해야 함
  - 삭제 알고리즘
    - LRU(Least Recently Used): 가장 오래전에 사용된 데이터 제거
    - LFU(Least Frequently Used): 가장 적게 사용된 데이터 제거
    - FIFO(First In First Out): 먼저 추가된 데이터 먼저 제거
  - 캐시가 가득 차 있지 않더라도 오래된 데이터는 미리미리 삭제하는 것이 좋음(사용하지 않을 가능성이 높은데, 굳이 캐시 용량을 차지할 필요가 없으니..)
    - 그래서 캐시에 만료 시간을 설정함 -> 일정 시간이 지나면 캐시에서 자동으로 삭제 -> 효율적인 메모리 관리 가능

**로컬 캐시와 리모트 캐시**

로컬 캐시: 서버 프로세스와 동일한 메모리를 캐시 저장소로 사용, In-memory Cache(메모리에 캐시 데이터를 보관하기 때문)
- 로컬 캐시 구현 방법: Caffeine, go_cache, node-cache
- 장점: 속도가 빠르다(네트워크를 안타니까), 외부 연동이 필요없으므로 구조가 단순함
- 단점: 캐시에 저장할 수 있는 데이터 크기에 제한이 있음(메모리 크기의 물리적 한계), 서버 프로세스를 재시작하면 메모리에 존재하던 캐시 데이터가 모두 삭제되어 일시적으로 적중률이 순간적으로 떨어짐
리모트 캐시: 별도 프로세스를 캐시 저장소로 사용
- 장점: 캐시 크기를 유연하게 확장 가능(여러 대의 Redis서버를 두어 수평 확장 가능), 서버 프로세스가 재시작되더라도 캐시 데이터는 그대로 유지됨 -> 적중률을 높임
- 단점: 속도(네트워크 통신 필수), 별도의 서버 장비와 프로세스가 필요하므로 시스템 구조가 복잡함

로컬 캐시, 리모트 캐시는 용도에 맞게 사용해야 함

만약 홈 화면에 표시할 최신 공지 목록은 많아야 10개 미만이고 잘 변경되지 않기 때문에 로컬 캐시를 사용하기에 적절
- 즉, 자주 바뀌지 않고 크기가 작은 데이터는 로컬 캐시에 저장

리모트 캐시에는 데이터 규모가 큰 데이터를 저장함. 트래픽이 많은 사이트의 개별 제품 정보(상품 상세) 데이터 저장 -> 대량의 상품 데이터를 캐시에 저장하기에는 로컬 캐시 메모리 한계가 있음
또한, 일부 데이터를 로컬 캐시에 저장하더라도 데이터가 수시로 변경되면 적중률 감소.
배포 빈도가 높은 서비스일 때, 리모트 캐시를 사용하면 좋음
- 만약 로컬 캐시에 저장한다면, 서버 재시작마다 캐시 데이터를 처음부터 쌓아야함(날아가니까..) -> 그래서 적중률도 응답시간도 영향이 감
- 리모트 캐시를 이용할 경우, 서버 재시작마다 캐시 데이터가 유지되므로 응답 시간을 일정 수준으로 유지 가능

**캐시 사전 적재**

  ### 읽어볼 자료들
  [HikariCP로 MySQL Connection Pool 최적화하기](https://cheese10yun.github.io/mysql-connection-pool-timeout-1/)
