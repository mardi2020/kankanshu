# 처리량과 응답 시간
응답시간: 사용자의 요청을 처리하는데 걸리는 시간, API 요청부터 SQL을 실행하고 JSON이 client로 반환될 때까지의 모든 시간
- client가 server로 요청을 보내는 과정
  - TCP를 이용해 서버에 연결, protocol에 맞춰 데이터 전송
- 응답시간의 측정
  - TTFB(Time to First Byte): 응답 데이터 중 첫번째 바이트가 도착할 때까지 걸린시간
  - TTLB(Time to Last Byte): 응답 데이터의 마지막 바이트가 도착할 때까지 걸린시간
  - 파일 크기가 커질 경우, TTFB와 TTLB 간의 차이가 커지기 때문에, 데이터의 특성이나 네트워크 환경을 고려해 두개 중 적절한 지표를 택해 측정해야 함
- 응답시간의 구성
  - 로직 수행(if, for 등), SQL 실행, 외부 API 연동, 응답 데이터 생성 중 **DB 연동과 API 연동이 큰 비중임**

처리량: 단위 시간당 시스템이 처리하는 작업량
- TPS: Transaction Per Second
- RPS: Request Per Second
- 서버는 처리할 수 있는 최대 요청수가 있어서 최대 TPS를 초과하는 요청이 들어오면 앞선 요청 먼저 처리하기 때문에 응답 시간이 증가하게 됨
  - 서버가 동시에 처리할 수 있는 요청 수를 늘려 대기 시간 줄이기
  - 처리 시간 자체를 줄여 대기 시간 줄이기
- 현재 서버의 TPS와 응답 시간을 먼저 구하고 성능을 개선안을 도출해야 함
  - 모니터링 시스템(스카우터, 핀포인트, 뉴렐릭 도구 등)을 활용해 실시간 TPS와 특정 시점의 TPS 확인 가능
 
병목 지점: 트래픽이 점점 늘면서 데이터가 쌓이고 간헐적으로 응답 시간이 느려지게 됨
- 전형적인 증상들
  - 순간적으로 모든 사용자 요청에 대한 응답 시간이 심각하게 느려짐(Timeout..)
  - 서버를 재시작하면 잠시 괜찮다가 다시 응답시간이 느려짐
  - 트래픽이 줄어들 때까지 지속됨
- 시스템이 수용할 수 있는 최대 TPS를 초과하는 트래픽이 유입되기 때문 -> 최대 TPS를 늘려야 함 -> 먼저 성능 문제 발생 지점을 찾자 -> 원인 분석 -> 개선안 도출
  - 모니터링 도구를 활용해 실제 실행 시간을 측정해 어떤 코드에서 실행 시간이 오래됐는지 찾자
  - 그리고 로그를 남기자

 수직 확장과 수평 확장
 - 수직 확장(Scale up): CPU, memory, disk 등 리소스를 증가시키는 것, 즉각적인 효과가 나타나지만 언제까지 늘릴수만은 없음
 - 수평 확장(Scale out): 서버를 늘리는 방법
   - 먼저 병목 지점을 파악하고 서버를 추가해야 함
     - 만약 DB에서 성능 문제가 발생하는데 DB를 사용하는 서버를 늘리면, DB에 가해지는 부하만 더 커지고 성능 문제가 심해짐(외부 API 호출도 마찬가지) 
 - 로드 밸런서: 사용자의 트래픽을 각 서버에 골고루 분배해 한 서버에 트래픽이 몰리는 것을 방지함, 전체 서버 자원을 효율적으로 사용 가능
   - 알고리즘
     - 정적 방식: 라운드로빈(클라이언트의 요청을 각 서버에 순차적으로 분배), IP 해시(클라이언트의 IP주소를 해시한 값을 기반으로 요청을 전달할 서버를 결정, 항상 동일한 서버로 지정)
     - 동적 방식: 서버의 현재 상태에 따라 트래픽을 분산, 트래픽이 더 적거나 응답 시간이 더 짧은 서버에 요청을 보냄
    
  DB connection pool
  - 네트워크에서 DB를 연결하고 종료하는 시간은 전체 응답시간에 영향을 주는 문제를 해결하기 위해 DB 커넥션 풀을 사용
  - 커넥션 풀: DB에 연결된 커넥션을 미리 생성해서 보관
    - 애플리케이션은 커넥션을 풀에서 가져오고, 작업완료시 다시 풀에 반환
    - 이미 연결된 커넥션을 재사용하므로 응답시간이 줄어들음
    - 설정 정보
      - 커넥션 풀 크기(또는 최소, 최대 크기): 미리 생성해둘 커넥션 개수 지정(가장 중요함!)
        - 트래픽이 순간적으로 급증할때, 커넥션 풀의 최소 크기를 최대 크기에 맞추는 것이 좋음(DB 연결 시간이 성능 저하의 주원인이 될 수도)
        - 그렇다고 무턱대고 늘리기만 하면 안됨, DB 서버의 CPU 사용률이 80%를 넘나드는 상황이면 DB에 가해지는 부하가 더 심해짐(크기를 유지하거나 더 줄이자)
      - 풀에 커넥션이 없을 때 커넥션을 구할 때까지 대기할 시간: 풀에 사용할 수 있는 커넥션이 없을 때 커넥션을 얻기 위해 기다릴 수 있는 최대 시간
        - HikariCP의 default 대기 시간: 30초
        - 지정된 대기 시간안에 커넥션을 구하지 못하면 DB 연결 실패 에러 발생
        - 대기시간 만큼 응답시간도 길어짐, 보통 0.5초에서 3초 이내로 지정하는 것이 좋음
        - 커넥션을 다 사용중일때, 무응답 상태로 유지되는 것보다 빠르게 에러를 반환하는 것이 나음 -> 서버의 부하 증가를 방지하게
      - 커넥션의 유지 시간(최대 유휴 시간, 최대 유지시간): 커넥션이 사용되지 않는 시간이 길어지면 연결이 끊어질 수 있음, 이때 DB와 연결이 끊긴 커넥션을 사용하면 에러가 발생함
        - 이러한 에러 방지를 위해 커넥션 풀은 2가지 기능 제공
          - 최대 유후 시간 지정: 사용되지 않는 커넥션을 풀에 유지할 수 있는 최대 시간
            - 이 시간을 DB에 설정된 비활성화 유지 시간보다 짧게 설정하면, DB가 연결을 끊기 전에 풀에서 커넥션 제거 가능
          - 유효성 검사 지원: 커넥션이 정상적으로 사용할 수 있는 상태인지 여부를 확인하는 절차
            - 이과정을 통해 연결이 유효하지 않은 커넥션을 식별하고 풀에서 제거 가능
            - 유효성 검사를 위해 `SELECT 1 FROM dual` 쿼리를 실행하기도 함
          - 최대 유지 시간: 만약 이 값이 4시간이면 커넥션은 생성된 시점부터 최대 4시간까지만 유지, 4시간이 지나면 커넥션이 유효하더라도 커넥션을 닫고 풀에서 제거됨

  서버 캐시
      
  
