# 파티셔닝
> 하나의 큰 테이블을 일정한 기준으로 여러 개의 작은 "파티션"으로 나누어 저장하는 기술

- Oracle에서는 하나의 테이블을 여러 개의 "파티션"으로 나누어 관리, query를 날릴 때에는 여전히 하나의 테이블처럼 사용 가능
  - Ex) review_logs 테이블에 1억건의 로그가 있다면
    - 한 테이블로 관리하면 검색할 때 항상 1억개의 데이터를 다 스캔해야할 수 있음
    - **월별로** 나누면, `review_logs_202507`(7월 로그 데이터), `review_logs_202508`(8월 로그 데이터) 처럼 분리되어 7월 데이터만 필요하면 **7월 파티션만 스캔하면 됨** -> 속도 개선

- 월별로 파티션을 나누는 이유
  - 로그 및 리뷰 데이터는 시간의 흐름에 따라 데이터가 계속 쌓임
  - Ex) `WHERE log_date BETWEEN '2025-07-01' AND '2025-07-31` 의 쿼리는 7월 파티션만 읽으면 됨 -> 1억건의 데이터를 모두 읽을 필요가 없어짐
  - 오래된 데이터를 삭제할 때 매우 빠름
    ```sql
    -- 2024년 1월의 데이터를 전체 삭제
    ALTER TABLE review_logs
    DROP PARTITION p202401;
    ```
    - DELETE로 수백만건을 지우는 것보다 훨씬 빠름
      - `DELETE FROM table WHERE 조건`
        - Oracle은 조건에 맞는 각 row를 하나씩 삭제함, 각 행마다 Undo/Redo 로그를 기록함(롤백할 때 사용해야 하므로 Undo 세그먼트에 기록됨)
        - 즉, 트랜잭션 커밋 전까지 데이터가 완전히 지워진 상태가 아님
        - 그래서 수백만건을 한번에 삭제할 경우, Redo/Undo 로그가 폭발적으로 증가하고 I/O가 많이 발생해서 성능이 매우 느려짐
    - **DROP PARTITION**의 동작 방식
      - 파티션 하나를 통쨰로 떼어내서 삭제함
      - Oracle에서는 해당 파티션에 연결된 세그먼트(데이터 블록)을 버려버리는 동작임
      - Undo/Redo 로그가 거의 발생하지 않음

- 왜 다음 년도가 오기 전에 파티션을 미리 생성할까?
  - 파티션은 **미리 정의된 범위**만 데이터 저장 가능
  - Ex) 2025년 1월 파티션이 없으면 `INSERT INTO review_logs VALUES (..., '2025-01-05')` 실행시 에러 발생
    - 수용할 파티션이 없기 때문
  - 자동으로 파티션이 생성되지 않음
  - Oracle에서는 사용자가 직접 `ALTER TABLE review_logs PARTITION review_logs_202601 VALUES LESS THAN (TO_DATE(...))`으로 파티션을 추가해야 함

### 정리
- 파티셔닝은 대용량 데이터를 가진 테이블을 작은 조각으로 나누는 기술
- 로그, 리뷰 데이터는 월별로 나누면 검색/삭업/백업이 빠르고 편함
- 파티션을 미리 생성해두지 않으면, 새로운 달의 데이터가 들어올 때 테이블이 해당 데이터를 저장할 파티션을 못 찾아 에러가 발생하게 됨
