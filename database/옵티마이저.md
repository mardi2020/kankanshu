# 옵티마이저

- MySQL 서버에서 쿼리 실행 절차
  - (1, SQL Parsing) SQL Parser - 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있도록 분리(parse tree)
    - result: SQL parse tree
  - (2, 최적화 및 실행 계획 수립) Optimizer - SQL parse tree를 참조하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
  - (3) (2) 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴

- 옵티마이저 종류
  - **비용 기반 최적화(Cost-based optimizer, CBO)**
    - 쿼리를 처리하기 위한 여러가지 가능한 방법을 만듦
    - 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용 산출
    - 비용이 최소가 되는 처리 방식을 선택
  - 규칙 기반 최적화(Rule-based optimizer, RBO)
    - 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않음
    - 옵티마이저에 내장된 우선순위에 따라 실행 계획 수립
    - 거의 사용되지 않는 방식

- 기본 데이터 처리
  - 풀 테이블 스캔
    - 풀 테이블 스캔으로 조회할 때
      - 테이블의 데이터 수가 너무 작을 떄
      - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
      - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
        (인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)
  - 풀 인덱스 스캔

- ORDER BY 처리
  - 정렬을 처리하는 방법
    - 인덱스를 이용하는 방법
      - INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬되어 있어 순서대로 읽기만 하면 됨 -> 조회에 빠름
      - INSERT, UPDATE, DELETE 작업시 부가적인 인덱스 추가/삭제 작업 필요 -> 느리고 인덱스의 추가 공간 필요
      - 인덱스의 개수가 늘어날 수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요
    - 쿼리가 실행될 때 "Filesort" 처리를 이용하는 방법
      - 인덱스를 생성하지 않아도 되므로 메모리 공간이 별도로 필요없음
      - 정렬해야 할 레코드가 많지 않을 경우, 메모리에서 Filesort가 처리되므로 충분히 빠름
      - 정렬 작업이 쿼리 실행시 처리되므로 데이터가 많아질수록 쿼리 응답 속도가 늦어짐
  - 아래 이유로 모든 정렬을 인덱스를 이용하도록 튜닝하기 어려움
    - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능할 때
    - GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야할 때
      - GROUP BY, DISTINCT 결과는 임시 테이블에 저장되고 원래 테이블의 인덱스 순서 정보가 포함되어 있지 않아 새로운 정렬 작업이 필요
    - UNION의 결과와 같이 임시 테이블과 결과를 다시 정렬해야 하는 경우
    - 랜덤하게 결과 레코드를 가져와야 하는 경우

  인덱스를 사용하지 않고 별도의 정렬 처리를 했는지는 실행 계획의 Extra 칼럼이 "Using filesort"로 표시되는지 확인
